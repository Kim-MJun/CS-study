# CORS 심화

> CORS의 동작 원리와 보안 의미를 정확히 이해하자.

---

## 1. CORS란?

### 1.1 Same-Origin Policy (SOP)

브라우저는 **다른 출처(Origin)**의 리소스 접근을 기본적으로 차단합니다.

**Origin = Protocol + Host + Port**

```
https://example.com:443
└─┬─┘   └────┬────┘ └┬┘
Protocol   Host    Port
```

| URL A                 | URL B                     | 동일 출처?   |
| --------------------- | ------------------------- | ------------ |
| `https://example.com` | `https://example.com/api` | O            |
| `https://example.com` | `http://example.com`      | X (프로토콜) |
| `https://example.com` | `https://api.example.com` | X (호스트)   |

### 1.2 CORS의 역할

**CORS**는 서버가 "이 출처는 허용한다"고 응답 헤더로 명시하면, 브라우저가 해당 출처의 JavaScript에서 응답에 접근할 수 있게 해주는 메커니즘입니다.

**핵심 포인트:**

- CORS는 **브라우저**가 강제 (curl, Postman은 CORS 무관)
- **서버 보호 목적 아님** → 사용자 브라우저 보호가 목적
- 요청은 서버에 **도달함** (Preflight 제외)

---

## 2. Simple Request vs Preflight Request

### 2.1 Simple Request

다음 조건을 **모두** 만족하면 Preflight 없이 바로 요청:

- 메서드: `GET`, `HEAD`, `POST`
- Content-Type: `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`
- 커스텀 헤더 없음

```
Browser ───── GET /data ─────> Server
        <──── 200 + ACAO ─────
```

### 2.2 Preflight Request

위 조건 불만족 시 **OPTIONS로 사전 확인** 후 본 요청:

```javascript
// Preflight 발생하는 경우
fetch(url, {
  method: 'DELETE', // Simple이 아닌 메서드
  headers: {
    'Content-Type': 'application/json', // Simple이 아닌 Content-Type
    Authorization: 'Bearer token', // 커스텀 헤더
  },
});
```

```
Browser ─── OPTIONS (허용 여부 확인) ──> Server
        <── 204 + 허용 헤더들 ───────────
        ─── POST /data (본 요청) ──────> Server
        <── 200 + 응답 ─────────────────
```

### 2.3 왜 구분할까?

HTML `<form>`은 CORS 이전부터 Cross-Origin POST가 가능했습니다. 기존 웹과의 호환성을 위해 form으로 가능했던 요청은 Simple로, 그 외는 Preflight로 검증합니다.

---

## 3. CORS 헤더 정리

### 요청 헤더 (브라우저가 자동 추가)

| 헤더                             | 설명                       |
| -------------------------------- | -------------------------- |
| `Origin`                         | 요청 출처                  |
| `Access-Control-Request-Method`  | Preflight 시 사용할 메서드 |
| `Access-Control-Request-Headers` | Preflight 시 사용할 헤더   |

### 응답 헤더 (서버가 설정)

| 헤더                               | 설명                          | 예시                            |
| ---------------------------------- | ----------------------------- | ------------------------------- |
| `Access-Control-Allow-Origin`      | 허용할 출처                   | `https://frontend.com` 또는 `*` |
| `Access-Control-Allow-Methods`     | 허용할 메서드                 | `GET, POST, PUT, DELETE`        |
| `Access-Control-Allow-Headers`     | 허용할 헤더                   | `Content-Type, Authorization`   |
| `Access-Control-Allow-Credentials` | 인증 정보 허용                | `true`                          |
| `Access-Control-Max-Age`           | Preflight 캐시 시간(초)       | `86400`                         |
| `Access-Control-Expose-Headers`    | JS에서 읽을 수 있는 응답 헤더 | `X-Request-Id`                  |

---

## 4. Credentials (인증 정보)

쿠키나 Authorization 헤더를 Cross-Origin 요청에 포함하려면:

```javascript
// 클라이언트
fetch(url, { credentials: 'include' });
```

```javascript
// 서버 (Express)
res.setHeader('Access-Control-Allow-Origin', 'https://frontend.com'); // * 불가!
res.setHeader('Access-Control-Allow-Credentials', 'true');
```

**주의:** `credentials: 'include'` 사용 시 `Allow-Origin: *` 사용 불가 → 명시적 출처 필요

---

## 5. 자주 마주치는 에러

### "No 'Access-Control-Allow-Origin' header"

서버에서 CORS 헤더 미설정. 서버에 헤더 추가 필요.

### Preflight 실패 (OPTIONS 405)

OPTIONS 핸들러가 없거나 인증 미들웨어가 OPTIONS를 차단.

```javascript
// OPTIONS는 인증 체크 건너뛰기
app.options('*', cors());
```

### credentials 에러

`Allow-Origin: *`와 `credentials: true` 함께 사용 불가. 명시적 출처로 변경.

---

## 6. 보안 관점

### CORS는 서버를 보호하지 않는다

```bash
# CORS는 브라우저만 강제. curl은 상관없이 데이터 받아옴
curl https://api.example.com/data
```

### CORS만으로 CSRF 방어 안 됨

Simple Request는 Preflight 없이 서버에 도달 → 상태 변경 가능.
CSRF 토큰, SameSite 쿠키 등 별도 방어 필요.

### 위험한 설정

```javascript
// 위험: 모든 Origin을 검증 없이 허용
res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
res.setHeader('Access-Control-Allow-Credentials', 'true');

// 안전: 화이트리스트 기반
const allowed = ['https://frontend.com'];
if (allowed.includes(origin)) {
  res.setHeader('Access-Control-Allow-Origin', origin);
}
```

---

## 7. CORS 우회 (Proxy)

### 7.1 핵심 원리

**CORS는 브라우저만 강제합니다. 서버 간 통신에는 CORS가 없습니다.**

```
❌ CORS 발생
┌──────────┐                              ┌──────────┐
│  브라우저  │ ─── fetch() ───────────────> │ API 서버  │
│ (A.com)  │      Origin이 다름 → CORS!    │ (B.com)  │
└──────────┘                              └──────────┘

✅ CORS 우회
┌──────────┐          ┌──────────┐          ┌──────────┐
│  브라우저  │ ──────> │  Proxy   │ ──────> │ API 서버  │
│ (A.com)  │ 같은출처  │ (A.com)  │ 서버간    │ (B.com)  │
└──────────┘ CORS무관  └──────────┘ CORS무관  └──────────┘
```

**Proxy가 CORS를 우회하는 이유:**

1. 브라우저 → Proxy: **같은 출처**이므로 CORS 체크 안 함
2. Proxy → API 서버: **서버 간 통신**이므로 CORS 개념 자체가 없음

---

### 7.2 개발 환경: Vite Proxy

```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'https://api.backend.com',
        changeOrigin: true,
      },
    },
  },
};
```

**동작 흐름:**

```
① 브라우저에서 fetch('/api/users') 호출

② 요청 URL: http://localhost:5173/api/users
   └─ 브라우저 입장: 같은 출처! (localhost:5173 → localhost:5173)
   └─ CORS 체크 안 함

③ Vite 개발 서버가 '/api' 요청을 가로챔
   └─ proxy 설정에 따라 실제 API 서버로 전달

④ Vite → API 서버 (https://api.backend.com/api/users)
   └─ 서버 간 통신 = CORS 없음!

⑤ 응답: API 서버 → Vite → 브라우저
```

```
브라우저                  Vite 개발서버              API 서버
(localhost:5173)        (localhost:5173)      (api.backend.com)
      │                       │                       │
      │  GET /api/users       │                       │
      │ ────────────────────> │                       │
      │   같은 출처 = OK       │  GET /api/users       │
      │                       │ ────────────────────> │
      │                       │   서버간 = CORS 무관   │
      │                       │ <──────────────────── │
      │ <──────────────────── │                       │
      │                       │                       │
```

---

### 7.3 프로덕션 환경: Nginx 리버스 프록시

```nginx
server {
    listen 80;
    server_name myapp.com;

    # 프론트엔드 정적 파일
    location / {
        root /var/www/frontend;
    }

    # /api 요청은 백엔드 서버로 전달
    location /api/ {
        proxy_pass https://api.backend.com/;
    }
}
```

**동작 흐름:**

```
브라우저                     Nginx                   API 서버
(myapp.com)               (myapp.com)          (api.backend.com)
      │                       │                       │
      │ GET myapp.com/api/users                       │
      │ ────────────────────> │                       │
      │   같은 출처 = OK       │  GET /users           │
      │                       │ ────────────────────> │
      │                       │   서버간 = CORS 무관   │
      │                       │ <──────────────────── │
      │ <──────────────────── │                       │
```

**브라우저가 보는 것:**

- 프론트엔드: `https://myapp.com/index.html`
- API 요청: `https://myapp.com/api/users`
- **같은 출처 (myapp.com)** → CORS 발생 안 함!

---

### 7.4 방법 비교

| 방법                | 환경     | 설정 위치      | 원리                                    |
| ------------------- | -------- | -------------- | --------------------------------------- |
| Vite/CRA Proxy      | 개발     | vite.config.js | 개발 서버가 API 요청 대신 전달          |
| Nginx 리버스 프록시 | 프로덕션 | nginx.conf     | 같은 도메인에서 프론트/API 서비스       |
| 서버 CORS 설정      | 프로덕션 | 백엔드 코드    | `Access-Control-Allow-Origin` 헤더 추가 |

**언제 어떤 방법?**

- **개발 중**: Vite/CRA Proxy (간편함)
- **프로덕션 (같은 도메인)**: Nginx 리버스 프록시
- **프로덕션 (다른 도메인)**: 서버에서 CORS 헤더 설정

---

## 8. 면접 핵심 Q&A

### Q1. CORS가 무엇인가요?

> CORS는 브라우저의 Same-Origin Policy를 안전하게 완화하는 메커니즘입니다. 서버가 응답 헤더로 허용할 출처를 명시하면, 브라우저가 해당 출처의 JavaScript에서 응답에 접근할 수 있게 합니다. 중요한 점은 CORS는 브라우저가 강제하는 정책이며, 서버가 아닌 사용자 브라우저를 보호하는 것입니다.

### Q2. Simple Request와 Preflight의 차이는?

> Simple Request는 GET/POST + form 데이터 등 특정 조건을 만족하면 바로 요청을 보내고, Preflight는 조건 불만족 시 OPTIONS로 먼저 허용 여부를 확인합니다. 이 구분은 HTML form이 CORS 이전부터 Cross-Origin 요청이 가능했던 역사적 호환성 때문입니다.

### Q3. CORS가 CSRF를 막아주나요?

> 아닙니다. Simple Request는 Preflight 없이 서버에 도달하므로 상태 변경이 가능합니다. CORS는 응답을 읽을 수 있는지만 제어하지, 요청 자체를 막지 않습니다. CSRF 방어는 CSRF 토큰, SameSite 쿠키 등 별도 대책이 필요합니다.

### Q4. credentials 사용 시 주의점은?

> `credentials: 'include'` 사용 시 서버에서 `Access-Control-Allow-Origin: *`를 사용할 수 없고, 명시적 출처를 지정해야 합니다. 또한 `Access-Control-Allow-Credentials: true` 헤더가 필요하고, 쿠키는 `SameSite=None; Secure` 설정이 필요합니다.

---

## 9. 요약

| 개념           | 핵심                                         |
| -------------- | -------------------------------------------- |
| SOP            | 다른 출처 리소스 접근 차단 (브라우저 보안)   |
| CORS           | SOP를 안전하게 완화하는 메커니즘             |
| Simple Request | GET/POST + form data → Preflight 없음        |
| Preflight      | DELETE, 커스텀 헤더 등 → OPTIONS로 사전 확인 |
| credentials    | `*` 사용 불가, 명시적 출처 필요              |
| 보안           | CORS는 서버 보호 X, CSRF 방어 X              |
