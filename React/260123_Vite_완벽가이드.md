# Vite 완벽 가이드

## 1. Vite의 핵심 동작 원리

### 1.1 Dependencies vs Source Code 분리

Vite가 빠른 가장 근본적인 이유는 **두 가지 유형의 코드를 다르게 처리**하기 때문입니다.

```javascript
// src/main.jsx
import React from 'react'          // Dependencies → esbuild로 사전 번들링
import ReactDOM from 'react-dom'   // Dependencies → esbuild로 사전 번들링
import App from './App.jsx'        // Source Code → Native ESM으로 제공
```

**Dependencies (node_modules):**
- 거의 변경되지 않음
- CommonJS, UMD 등 다양한 포맷 → ESM으로 통일 필요
- esbuild(Go 언어)로 사전 번들링
- `node_modules/.vite` 디렉토리에 캐시
- 강력한 HTTP 캐싱 (`max-age=31536000,immutable`)

**Source Code (src/):**
- 자주 변경됨
- 이미 ESM으로 작성됨
- 번들링 없이 Native ESM으로 제공
- 브라우저가 요청할 때만 변환 (on-demand)
- `304 Not Modified`로 조건부 캐싱

```
Webpack: Entry → 전체 의존성 분석 → 모든 모듈 번들링 → 서버 구동
Vite:    서버 즉시 구동 → 브라우저가 import 요청 → 해당 모듈만 변환하여 응답
```

### 1.2 Native ES Modules 활용

브라우저가 직접 ESM을 해석합니다:

```html
<!-- Vite 개발 서버가 제공하는 HTML -->
<script type="module" src="/src/main.jsx"></script>
```

```javascript
// 브라우저가 main.jsx를 받으면
import App from './App.jsx'  // 브라우저가 /src/App.jsx를 추가 요청
import './index.css'         // 브라우저가 /src/index.css를 추가 요청

// App.jsx 내부에서
import Button from './Button.jsx'  // 또 추가 요청... (waterfall)
```

**Waterfall 문제:**

모듈이 깊게 중첩되면 요청이 순차적으로 발생합니다. Vite는 이를 두 가지로 해결합니다:

1. **의존성 사전 번들링**: lodash-es 같은 패키지는 600개+ 모듈 → 하나로 번들링
2. **Module Preload**: 정적 분석으로 필요한 모듈을 미리 `<link rel="modulepreload">`로 힌트 제공

### 1.3 HMR (Hot Module Replacement)

**Vite HMR 동작 과정:**

```
1. 파일 변경 감지 (chokidar)
2. 변경된 모듈의 invalidation boundary 탐색
3. WebSocket으로 브라우저에 알림: { type: 'update', path: '/src/Button.jsx' }
4. 브라우저가 해당 모듈만 재요청 (timestamp query string으로 캐시 무효화)
5. 프레임워크 플러그인이 컴포넌트 상태 유지하며 교체
```

**HMR Boundary:**

```javascript
// React 플러그인이 자동으로 HMR boundary 설정
// Button.jsx 수정 시 → Button만 교체, 상위 컴포넌트 상태 유지

export default function Button() {
  return <button>Click</button>
}

// React Fast Refresh가 내부적으로 이렇게 처리:
if (import.meta.hot) {
  import.meta.hot.accept()  // 이 모듈이 HMR boundary
}
```

**프로젝트 크기와 무관한 이유:**

Webpack은 변경 시 영향받는 청크를 재번들링하지만, Vite는 해당 ESM 모듈 하나만 무효화합니다. 의존성 그래프 탐색만 하고 번들링은 하지 않습니다.

---

## 2. 번들러 심층 비교

### 2.1 esbuild

Go 언어로 작성된 번들러. JavaScript 번들러 대비 10-100배 빠름.

**왜 빠른가:**
- Go의 병렬 처리 (goroutine)
- 네이티브 코드로 컴파일
- AST를 최소한으로 순회
- 메모리 효율적 사용

**Vite에서의 역할 (7 이하):**
- 의존성 사전 번들링 (`node_modules/.vite`)
- TypeScript → JavaScript 변환 (타입 체크 없이 strip만)
- JSX 변환

**한계:**
```javascript
// esbuild는 타입 체크를 하지 않음
const x: string = 123  // esbuild는 통과, tsc는 에러

// ES5 타겟 미지원 (ES2015+만)
// 일부 플러그인 훅 미지원 (load, resolve만 기본 제공)
```

### 2.2 Rollup

ES Module 중심 설계의 번들러. Tree-shaking을 대중화시킴.

**Tree-shaking 동작 원리:**

```javascript
// math.js
export const add = (a, b) => a + b
export const subtract = (a, b) => a - b  // 미사용

// app.js
import { add } from './math.js'
console.log(add(1, 2))
```

Rollup의 처리:
1. AST 파싱 → import/export 바인딩 수집
2. 각 export가 실제로 사용되는지 추적
3. `subtract`는 어디서도 import되지 않음 → 제거
4. 부수 효과(side effect) 분석 → 안전하면 제거

**플러그인 훅 시스템:**

```javascript
export default function myPlugin() {
  return {
    name: 'my-plugin',

    // === Build Hooks ===
    buildStart(options) {},           // 빌드 시작
    resolveId(source, importer) {     // 모듈 ID 해석
      // 'virtual:my-module' → 가상 모듈 생성 가능
      if (source === 'virtual:config') {
        return source  // 이 ID를 처리하겠다고 선언
      }
    },
    load(id) {                        // 모듈 내용 로드
      if (id === 'virtual:config') {
        return 'export default { foo: 1 }'  // 가상 파일 내용
      }
    },
    transform(code, id) {             // 코드 변환
      // TypeScript, JSX, CSS 등 변환
      return { code: transformedCode, map: sourceMap }
    },

    // === Output Hooks ===
    renderChunk(code, chunk) {},      // 청크별 후처리
    generateBundle(options, bundle) {}, // 최종 번들 조작
  }
}
```

**Vite에서의 역할 (7 이하):**
- 프로덕션 빌드 전담
- 코드 스플리팅, Tree-shaking
- 플러그인 생태계 활용

### 2.3 Rolldown

Rust로 작성. Rollup 호환 API + esbuild 수준 속도.

**탄생 배경:**

```
Vite 7 이하의 문제:
┌────────────────────────────────────────────────────┐
│  개발: esbuild          프로덕션: Rollup           │
│  - TS 변환 방식 다름    - TS 변환 방식 다름        │
│  - 모듈 해석 다름       - 모듈 해석 다름           │
│  → 개발에서 됐는데 빌드에서 안 되는 경우 발생      │
└────────────────────────────────────────────────────┘
```

**아키텍처:**

```
Rolldown
├── Oxc (Rust 기반 컴파일러 도구)
│   ├── Parser (Babel보다 3배 빠름)
│   ├── Transformer (TypeScript, JSX)
│   ├── Resolver (모듈 해석)
│   └── Minifier (Terser 대체)
└── Bundling Engine
    ├── 병렬 모듈 처리 (Rayon)
    ├── 증분 빌드
    └── Rollup 호환 플러그인 실행
```

**성능이 빠른 이유:**

| 특성 | JavaScript (Rollup) | Rust (Rolldown) |
|------|---------------------|-----------------|
| 메모리 | GC 런타임 오버헤드 | 컴파일 타임 관리 (제로 코스트) |
| 병렬성 | Worker 기반 (IPC 오버헤드) | 네이티브 스레드 (공유 메모리) |
| 문자열 | UTF-16 (변환 필요) | UTF-8 직접 처리 |
| 파싱 | 인터프리터 실행 | 네이티브 코드 |

**Rollup 플러그인 호환:**

```javascript
// 기존 Rollup 플러그인 그대로 사용
import commonjs from '@rollup/plugin-commonjs'

// Rolldown은 JS 플러그인을 Node.js 브릿지로 실행
// 성능 크리티컬한 플러그인은 Rust 네이티브 버전 제공 예정
```

**벤치마크:**

| 프로젝트 | Rollup (Vite 7) | Rolldown (Vite 8) | 개선 |
|----------|-----------------|-------------------|------|
| Linear (대규모) | 46초 | 6초 | 7.6배 |
| 일반 프로젝트 | 15초 | 3초 | 5배 |

---

## 3. Vite 8 - Rolldown 통합

### 3.1 변경점

```
Vite 7 이하:
- 개발: esbuild (의존성 번들링) + 자체 변환
- 프로덕션: Rollup

Vite 8:
- 개발 + 프로덕션: Rolldown
- 통합 파이프라인으로 일관성 확보
```

### 3.2 마이그레이션 시 확인사항

```javascript
// 대부분의 Rollup 플러그인은 그대로 동작
// 하지만 내부 API를 직접 사용한 경우 확인 필요

// 예: this.emitFile, this.getModuleInfo 등
// Rolldown에서 동작이 약간 다를 수 있음

export default function myPlugin() {
  return {
    generateBundle(options, bundle) {
      // bundle 객체 구조는 호환되지만
      // 일부 메타데이터가 다를 수 있음
    }
  }
}
```

---

## 4. 실무 트러블슈팅

### 4.1 환경변수

```bash
# .env
# Webpack: REACT_APP_ 접두사
REACT_APP_API_URL=https://api.example.com

# Vite: VITE_ 접두사
VITE_API_URL=https://api.example.com
```

```javascript
// Webpack
process.env.REACT_APP_API_URL

// Vite
import.meta.env.VITE_API_URL

// 타입 정의 (src/vite-env.d.ts)
interface ImportMetaEnv {
  readonly VITE_API_URL: string
}
```

### 4.2 require() 사용 불가

```javascript
// CommonJS 동적 require - 안 됨
const module = require(`./modules/${name}.js`)

// ESM 동적 import - 사용
const module = await import(`./modules/${name}.js`)

// Glob import (Vite 전용)
const modules = import.meta.glob('./modules/*.js')
// { './modules/a.js': () => import('./modules/a.js'), ... }

// 즉시 로드
const modules = import.meta.glob('./modules/*.js', { eager: true })
// { './modules/a.js': { default: ... }, ... }
```

### 4.3 HMR이 안 될 때

**1. 순환 참조:**
```javascript
// A.jsx → B.jsx → A.jsx
// HMR이 무한 루프에 빠질 수 있음
// 해결: 공통 모듈로 분리
```

**2. Named + Default Export 혼용:**
```javascript
// 문제가 될 수 있음
export default function App() {}
export const helper = () => {}

// React Fast Refresh는 default export만 추적
// helper 변경 시 전체 리로드될 수 있음
```

**3. 컴포넌트 외부 상태:**
```javascript
// 모듈 스코프 변수는 HMR 시 초기화됨
let count = 0  // HMR마다 0으로 리셋

export default function Counter() {
  // useState 사용해야 상태 유지
  const [count, setCount] = useState(0)
}
```

### 4.4 의존성 최적화

```javascript
// vite.config.js
export default defineConfig({
  optimizeDeps: {
    // 동적 import되는 의존성은 자동 감지 안 됨 → 명시적 포함
    include: ['lodash-es', 'axios'],

    // 이미 ESM이고 의존성 없는 패키지는 제외 (번들링 스킵)
    exclude: ['@vueuse/core'],

    // CJS → ESM 변환 시 named export 감지 실패하는 경우
    esbuildOptions: {
      plugins: [/* custom plugin */]
    }
  }
})
```

### 4.5 청크 최적화

```javascript
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // 벤더 분리
          'vendor-react': ['react', 'react-dom'],
          'vendor-ui': ['@mui/material', '@emotion/react'],

          // 또는 함수로 세밀하게 제어
          // manualChunks(id) {
          //   if (id.includes('node_modules')) {
          //     return 'vendor'
          //   }
          // }
        }
      }
    },
    // 청크 크기 경고 임계값
    chunkSizeWarningLimit: 500,
  }
})
```

---

## 5. Vite를 선택하면 안 되는 경우

### IE11 지원 필수

```javascript
// @vitejs/plugin-legacy로 가능하긴 함
import legacy from '@vitejs/plugin-legacy'

export default defineConfig({
  plugins: [
    legacy({
      targets: ['ie >= 11'],
      additionalLegacyPolyfills: ['regenerator-runtime/runtime']
    })
  ]
})

// 하지만:
// - 빌드 시간 증가
// - 번들 크기 증가 (modern + legacy 두 벌)
// - 일부 최신 기능 polyfill 불완전
// → Webpack이 더 안정적
```

### Module Federation

```javascript
// Webpack 5 Module Federation - 마이크로 프론트엔드 핵심
new ModuleFederationPlugin({
  name: 'host',
  remotes: {
    app1: 'app1@http://localhost:3001/remoteEntry.js',
  },
})

// Vite는 vite-plugin-federation으로 지원하지만
// - 실험적 단계
// - 모든 케이스 커버 안 됨
// → MFE가 핵심이면 Webpack 권장
```

### 극도로 복잡한 로더 체인

```javascript
// Webpack의 강력한 로더 체인
{
  test: /\.md$/,
  use: [
    'html-loader',
    'markdown-loader',
    'custom-transform-loader',
    'another-loader'
  ]
}

// Vite는 플러그인으로 가능하지만
// 기존 Webpack 로더를 직접 사용할 수 없음
// 복잡한 커스텀 파이프라인이 있다면 마이그레이션 비용 큼
```

---

## 6. 2025년 Vite 생태계

### 6.1 핵심 도구

**Vitest:**
```javascript
// vite.config.js와 설정 공유
// Jest 호환 API
import { describe, it, expect } from 'vitest'

describe('math', () => {
  it('adds', () => {
    expect(1 + 1).toBe(2)
  })
})

// 브라우저 모드 지원 (실제 브라우저에서 테스트)
// 컴포넌트 테스트 내장
```

**Oxlint:**
```bash
# ESLint 대비 30-100배 빠름
# Rust 기반
oxlint src/

# 2025년: JavaScript 플러그인 지원 추가
# 점진적으로 ESLint 대체 가능
```

### 6.2 Vite+ (ViteConf 2025)

```bash
# 통합 CLI
vite dev          # 개발 서버
vite build        # 프로덕션 빌드
vite+ test        # Vitest
vite+ lint        # Oxlint
vite+ format      # Oxfmt (Prettier 대체)
vite+ bundle      # tsdown (라이브러리 번들링)
```

모노레포 퍼스트, 내장 캐싱, 네이티브 속도.

### 6.3 프레임워크 채택 현황

**Vite 기본:**
- Nuxt, SvelteKit, Astro, Remix, SolidStart, Qwik City

**자체 번들러:**
- Next.js (Turbopack)

---

## 7. 면접 예상 질문 & 답변

### Q1. Vite가 Webpack보다 빠른 이유는?

> "세 가지 핵심 전략 때문입니다.
>
> 첫째, Dependencies와 Source Code를 분리합니다. node_modules는 esbuild로 사전 번들링하고, 소스 코드는 Native ESM으로 제공합니다. esbuild는 Go로 작성되어 JavaScript 번들러보다 10-100배 빠릅니다.
>
> 둘째, 개발 서버가 번들링을 하지 않습니다. Webpack은 모든 모듈을 번들링한 후 서버를 시작하지만, Vite는 서버를 먼저 시작하고 브라우저가 요청하는 모듈만 on-demand로 변환합니다.
>
> 셋째, HMR이 ESM 기반입니다. 파일 수정 시 해당 모듈만 무효화하고, 브라우저가 재요청합니다. 번들 재생성이 없어서 프로젝트 크기와 무관하게 빠릅니다."

### Q2. 개발과 프로덕션 환경이 다른데 문제없나?

> "Vite 7 이하에서는 개발에 esbuild, 프로덕션에 Rollup을 사용했습니다. 이론적으로 동작 차이가 있을 수 있지만, 실무에서는 거의 문제없었습니다. Vite가 플러그인 레이어에서 차이를 추상화했고, 둘 다 ESM 표준을 따르기 때문입니다.
>
> 2025년 Vite 8부터는 Rolldown으로 통합되어 개발/프로덕션 모두 동일한 번들러를 사용합니다. Rolldown은 Rust 기반으로 esbuild 수준 속도를 내면서 Rollup 플러그인 API와 호환됩니다. 이제 환경 차이 문제가 완전히 해결되었습니다."

### Q3. esbuild, Rollup, Rolldown 차이는?

> "**esbuild**는 Go로 작성되어 매우 빠르지만, 플러그인 API가 제한적이고 Tree-shaking이 Rollup보다 약합니다. Vite 7 이하에서 의존성 사전 번들링과 TS/JSX 변환에 사용됩니다.
>
> **Rollup**은 JavaScript로 작성되었고, ES Module 중심 설계로 Tree-shaking이 우수합니다. 풍부한 플러그인 생태계가 있지만, JS 기반이라 대규모 프로젝트에서 느립니다.
>
> **Rolldown**은 Rust로 작성된 차세대 번들러입니다. Rollup 플러그인 API를 호환하면서 esbuild 수준 속도를 제공합니다. 내부적으로 Oxc(파서, 변환기, 미니파이어)를 사용하고, Vite 8부터 개발과 프로덕션 모두에서 사용됩니다."

### Q4. HMR이 어떻게 동작하나?

> "Vite HMR은 다섯 단계로 동작합니다.
>
> 1. chokidar가 파일 변경을 감지합니다.
> 2. 변경된 모듈의 HMR boundary를 탐색합니다. React 플러그인은 컴포넌트 파일마다 자동으로 boundary를 설정합니다.
> 3. WebSocket으로 브라우저에 업데이트를 알립니다.
> 4. 브라우저가 해당 모듈만 재요청합니다. timestamp query string으로 캐시를 무효화합니다.
> 5. React Fast Refresh 같은 런타임이 컴포넌트 상태를 유지하면서 교체합니다.
>
> Webpack과 달리 번들 재생성이 없어서, 프로젝트 크기와 무관하게 50ms 이내로 반영됩니다."

### Q5. Vite의 단점은?

> "세 가지 단점이 있습니다.
>
> 첫째, IE11 지원이 복잡합니다. @vitejs/plugin-legacy로 가능하지만, modern/legacy 두 벌 번들이 생성되고 일부 polyfill이 불완전합니다. IE11 필수라면 Webpack이 안정적입니다.
>
> 둘째, Module Federation이 실험적입니다. 마이크로 프론트엔드가 핵심이라면 Webpack 5가 낫습니다.
>
> 셋째, 기존 Webpack 로더를 직접 사용할 수 없습니다. 복잡한 커스텀 로더 체인이 있다면 마이그레이션 비용이 큽니다.
>
> 하지만 대부분의 현대 프로젝트에서는 이런 단점이 문제되지 않습니다."

### Q6. 언제 Webpack을, 언제 Vite를?

> "**Webpack을 유지해야 하는 경우:**
> - IE11 필수 지원
> - Module Federation이 핵심 (마이크로 프론트엔드)
> - 복잡한 커스텀 로더 체인이 있을 때
> - 마이그레이션 비용이 개선 효과보다 클 때
>
> **Vite를 선택해야 하는 경우:**
> - 신규 프로젝트
> - 현대 브라우저만 지원
> - 개발 경험 개선이 필요할 때
> - React, Vue, Svelte 등 모던 프레임워크
>
> 특별한 이유가 없다면 신규 프로젝트는 Vite로 시작하고, 레거시는 개선 효과와 비용을 비교해서 결정합니다."

---

## 요약

| 개념 | 핵심 |
|------|------|
| Vite 속도 비결 | Dependencies/Source 분리 + Native ESM + on-demand 변환 |
| esbuild | Go 기반, 빠름, 플러그인 제한적, TS strip만 (타입 체크 X) |
| Rollup | JS 기반, Tree-shaking 우수, 플러그인 풍부, 느림 |
| Rolldown | Rust 기반, Rollup 호환 + esbuild 속도, Vite 8 기본 |
| HMR | ESM 모듈 단위 무효화, 프로젝트 크기와 무관 |
| Webpack 선택 | IE11, Module Federation, 복잡한 로더 체인 |

---

**작성일**: 2026-01-26
**키워드**: #Vite #Webpack #번들러 #esbuild #Rollup #Rolldown #HMR #ESM
