# Webpack을 떠나 Vite를 선택한 이유

> "개발 서버가 켜지는데 10초가 걸립니다. 코드 한 줄 수정했는데 HMR이 3초 뒤에 반영됩니다."

이 글에서는 Webpack의 한계, Vite의 등장 배경, 그리고 왜 Vite가 현대 프론트엔드 개발의 새로운 표준이 되고 있는지 실무 관점에서 다룹니다.

---

## 1. Webpack의 한계 - 우리가 겪었던 고통

### 1.1 개발 서버 시작의 고통

**Webpack의 동작 방식:**
```
소스 코드 → 전체 의존성 분석 → 모든 모듈 번들링 → 서버 구동
```

프로젝트가 커질수록 개발 서버를 시작하는 데 걸리는 시간이 기하급수적으로 증가합니다.

**실제 경험:**
- 작은 프로젝트(~100 모듈): 3-5초
- 중간 프로젝트(~500 모듈): 7-10초
- 대규모 프로젝트(1000+ 모듈): 15-30초 이상

아침에 출근해서 개발 서버를 켜고 커피를 마시러 가는 게 일상이었습니다.

### 1.2 HMR(Hot Module Replacement)의 한계

Webpack의 HMR은 다음과 같이 동작합니다:

```
파일 수정 → 의존성 그래프 재분석 → 영향받는 번들 재생성 → HMR 전송
```

**문제점:**
- 프로젝트가 커질수록 HMR 속도 저하
- 대규모 프로젝트에서는 HMR이 2-3초 이상 걸림
- 때로는 전체 페이지 리로드가 더 빠른 경우도 있음

**개발 생산성 저하:**
```
코드 수정 → 저장 → 3초 대기 → 확인 → 또 수정 → 3초 대기...
```

하루 100번 수정한다면? 300초 = 5분을 그냥 기다리는 데 쓰는 겁니다.

### 1.3 설정의 복잡성

**전형적인 Webpack 설정 파일:**
```javascript
// webpack.config.js (200줄+)
module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    publicPath: '/',
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx|ts|tsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              '@babel/preset-env',
              '@babel/preset-react',
              '@babel/preset-typescript',
            ],
            plugins: [
              '@babel/plugin-transform-runtime',
              // ... 10개 이상의 플러그인
            ],
          },
        },
      },
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'postcss-loader',
        ],
      },
      {
        test: /\.scss$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'postcss-loader',
          'sass-loader',
        ],
      },
      // ... 이미지, 폰트, SVG 등 수십 개의 rule
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({/* ... */}),
    new MiniCssExtractPlugin({/* ... */}),
    new DefinePlugin({/* ... */}),
    new CopyWebpackPlugin({/* ... */}),
    // ... 10개 이상의 플러그인
  ],
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10,
        },
        // ... 복잡한 chunk 분리 전략
      },
    },
    minimizer: [
      new TerserPlugin({/* ... */}),
      new CssMinimizerPlugin({/* ... */}),
    ],
  },
  devServer: {
    // ... 20줄 이상의 설정
  },
  // ... 더 많은 설정
};
```

**문제점:**
- 신입 개발자가 이해하기 어려움
- 유지보수 비용 증가
- 플러그인 간 충돌 가능성
- 업그레이드 시 breaking change 대응 어려움

---

## 2. Vite의 등장 - 패러다임의 전환

### 2.1 Vite가 해결한 근본 문제

Vite(프랑스어로 "빠른"이라는 뜻)는 Vue.js 창시자 Evan You가 만든 차세대 빌드 도구입니다.

**핵심 아이디어:**
> "브라우저가 이미 ES Modules를 지원하는데, 왜 개발 환경에서 모든 걸 번들링해야 하는가?"

### 2.2 Vite의 동작 원리

#### 개발 환경

**Webpack의 방식:**
```
Entry → 모든 모듈 분석 → 전체 번들링 → 서버 구동
시간: 10-30초
```

**Vite의 방식:**
```
서버 즉시 구동 → 브라우저가 요청하는 모듈만 변환해서 제공
시간: 1-2초
```

**상세 동작:**

1. **Dependencies (의존성 패키지)**
   ```
   node_modules 파일들은 거의 변경되지 않음
   → esbuild로 사전 번들링 (Go 언어, 매우 빠름)
   → 브라우저 캐시 활용
   ```

2. **Source Code (소스 코드)**
   ```
   개발자가 자주 수정하는 파일
   → Native ESM으로 제공
   → 필요한 모듈만 요청 시 변환
   ```

**예시:**
```javascript
// src/main.jsx
import React from 'react'          // Dependencies
import ReactDOM from 'react-dom'   // Dependencies
import App from './App.jsx'        // Source Code

ReactDOM.render(<App />, document.getElementById('root'))
```

Vite는 이렇게 처리합니다:
- `react`, `react-dom`: esbuild로 미리 번들링된 것 제공
- `App.jsx`: 브라우저가 요청할 때 ESM으로 변환해서 제공

#### 프로덕션 환경

개발과 프로덕션의 괴리를 줄이기 위해 **Rollup** 사용:
- Rollup은 ES Module에 최적화된 번들러
- Tree-shaking 우수
- 코드 스플리팅 지원
- 작은 번들 사이즈

**2025년 현재: Vite 8 (Rolldown 통합)**

Vite 8부터는 esbuild와 Rollup을 **Rolldown**으로 통합했습니다:
```
Vite 7 이하: esbuild (개발) + Rollup (프로덕션)
Vite 8 이상: Rolldown (개발 + 프로덕션 통합)
```

**Rolldown의 장점:**
- Rust 기반, esbuild 수준의 속도
- Rollup과 호환되는 플러그인 API
- 개발/프로덕션 동작 일관성
- 더 나은 Tree-shaking

---

## 3. Webpack vs Vite - 실전 비교

### 3.1 개발 서버 시작 속도

**테스트 환경:**
- React 프로젝트
- 약 500개 모듈
- MacBook Pro M1

| 번들러 | 개발 서버 시작 시간 |
|--------|-------------------|
| Webpack | 7.8초 |
| Vite | 1.8초 |
| **차이** | **약 4.3배 빠름** |

대규모 프로젝트(1000+ 모듈)에서는 **20-30배** 차이가 나기도 합니다.

### 3.2 HMR 속도

| 번들러 | HMR 반영 시간 |
|--------|-------------|
| Webpack | 1-3초 |
| Vite | 거의 즉시 (< 50ms) |

**왜 Vite의 HMR이 빠른가?**

Webpack의 HMR:
```
파일 수정 → 영향받는 번들 재생성 → 브라우저로 전송
프로젝트가 클수록 느려짐
```

Vite의 HMR:
```
파일 수정 → 해당 ESM 모듈만 무효화 → 브라우저에서 재요청
프로젝트 크기와 무관하게 빠름
```

Vite는 Native ESM을 활용하기 때문에, 수정된 모듈과 그 직계 의존성 체인만 무효화합니다. 앱 크기가 커져도 HMR 속도는 일정합니다.

### 3.3 설정 파일 비교

**Vite 설정 파일:**
```javascript
// vite.config.js (20-30줄)
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  },
  build: {
    outDir: 'dist',
  },
})
```

**특징:**
- 간결함
- 합리적인 기본값
- 필요한 것만 설정
- 타입 지원 (defineConfig)

### 3.4 프로덕션 빌드 속도

**실제 프로젝트 사례 (Airbridge 대시보드):**

| 환경 | Webpack | Vite |
|------|---------|------|
| 평균 빌드 시간 | 250초 | 90초 |
| 개선율 | - | **64% 빠름** |

**Vite 8 (Rolldown) 사례:**

Linear 프로덕션 빌드:
- Rollup(Vite 7): 46초
- Rolldown(Vite 8): 6초
- **7.6배 개선**

### 3.5 기능 비교표

| 기능 | Webpack | Vite |
|------|---------|------|
| **개발 서버 시작** | 느림 (7-30초) | 매우 빠름 (1-2초) |
| **HMR 속도** | 느려짐 (프로젝트 증가 시) | 일정함 (프로젝트 크기 무관) |
| **설정 복잡도** | 높음 | 낮음 |
| **플러그인 생태계** | 매우 풍부 | 빠르게 성장 중 |
| **커스터마이징** | 매우 유연 | 적당히 유연 |
| **번들 크기** | 최적화 가능 | 기본으로 최적화됨 |
| **Tree-shaking** | 양호 | 우수 (Rollup/Rolldown) |
| **레거시 브라우저** | 완벽 지원 | 플러그인 필요 (@vitejs/plugin-legacy) |
| **학습 곡선** | 가파름 | 완만함 |

---

## 4. Vite의 핵심 개념

### 4.1 Native ES Modules (ESM)

**전통적인 방식 (Webpack):**
```html
<!-- 번들된 하나의 파일 -->
<script src="/bundle.js"></script>
```

**Vite 방식:**
```html
<!-- Native ESM 사용 -->
<script type="module" src="/src/main.jsx"></script>
```

브라우저가 직접 import를 해석하고 필요한 모듈만 요청합니다.

```javascript
// main.jsx
import App from './App.jsx'  // 브라우저가 ./App.jsx를 요청
import './index.css'          // CSS도 ESM으로 처리

// App.jsx에서
import Button from './Button.jsx'  // 브라우저가 ./Button.jsx를 요청
```

### 4.2 Dependencies vs Source Code 분리

**Dependencies (node_modules):**
- 거의 변경되지 않음
- esbuild로 사전 번들링
- 강력한 브라우저 캐싱 활용

**Source Code (src/):**
- 자주 변경됨
- 필요할 때만 변환
- Native ESM으로 제공

이 분리 전략이 Vite가 빠른 핵심 이유입니다.

### 4.3 esbuild - Go의 속도

esbuild는 Go 언어로 작성된 번들러입니다.

**속도 비교:**
```
Webpack (JavaScript): 100x 기준
Rollup (JavaScript):  ~100x
esbuild (Go):         1x (100배 빠름)
```

**Vite에서 esbuild 사용:**
- 의존성 사전 번들링
- TypeScript, JSX 변환
- 개발 중 코드 변환

### 4.4 Rollup - 프로덕션 최적화

**Rollup의 장점:**
- ES Module 우선 설계
- 우수한 Tree-shaking
- 깔끔한 번들 출력
- 코드 스플리팅

**Vite + Rollup:**
```
개발: esbuild (속도 우선)
프로덕션: Rollup (최적화 우선)
```

### 4.5 HMR의 진화

**Webpack HMR:**
```
1. 파일 변경 감지
2. 의존성 그래프 재분석
3. 영향받는 번들 재생성
4. WebSocket으로 HMR 전송
5. 브라우저에서 모듈 교체
```

**Vite HMR:**
```
1. 파일 변경 감지
2. 해당 ESM 모듈만 무효화
3. WebSocket으로 무효화 알림
4. 브라우저가 해당 모듈 재요청
5. 즉시 반영
```

**HMR Boundary (경계) 개념:**
```javascript
// Button.jsx
export default function Button() {
  return <button>Click</button>
}

// Button.jsx를 수정하면
// → Button.jsx만 교체
// → 상위 컴포넌트는 재렌더링하지 않음
// → 상태 유지됨
```

React, Vue 등 프레임워크 플러그인이 자동으로 HMR Boundary를 설정해줍니다.

---

## 5. 주의사항 & 트러블슈팅

### 5.1 Vite를 선택하면 안 되는 경우

❌ **극도로 복잡한 커스텀 빌드 로직이 필요한 경우**
- Webpack의 강력한 로더 시스템이 필요한 경우
- 예: 특수한 파일 형식을 여러 단계로 변환

❌ **IE11 같은 레거시 브라우저를 반드시 지원해야 하는 경우**
- @vitejs/plugin-legacy로 가능하긴 하지만 복잡함
- Webpack이 더 안정적

❌ **Module Federation이 핵심 기능인 경우**
- Webpack 5의 Module Federation 사용
- Vite는 실험적 지원

❌ **팀 전체가 Webpack에 익숙하고, 마이그레이션 비용이 큰 경우**
- 레거시 대규모 프로젝트
- 당장의 개선이 시급하지 않은 경우

### 5.2 자주 겪는 문제들

#### 1) 환경변수 이름

**Webpack:**
```javascript
process.env.REACT_APP_API_URL
```

**Vite:**
```javascript
import.meta.env.VITE_API_URL
```

`.env` 파일:
```bash
# Webpack
REACT_APP_API_URL=https://api.example.com

# Vite
VITE_API_URL=https://api.example.com
```

#### 2) Public 디렉토리

**Webpack:**
```
public/images/logo.png
→ /images/logo.png
```

**Vite:**
```
public/images/logo.png
→ /images/logo.png (동일)
```

하지만 번들에 포함시키려면:
```javascript
// Vite에서 이미지를 import
import logo from './assets/logo.png'  // 번들에 포함
```

#### 3) require() 사용 불가

Vite는 ES Module만 지원합니다.

**안 됨:**
```javascript
const image = require('./image.png')
```

**해야 함:**
```javascript
import image from './image.png'
```

동적 import는:
```javascript
// Webpack
const module = require(`./modules/${name}.js`)

// Vite
const module = await import(`./modules/${name}.js`)
```

#### 4) HMR이 작동하지 않는 경우

**원인 1: 순환 참조 (Circular Import)**
```javascript
// A.jsx
import B from './B.jsx'

// B.jsx
import A from './A.jsx'  // 순환 참조!
```

**원인 2: Named Export와 Default Export 혼용**
```javascript
// App.jsx
export default App
export const foo = 12  // 이렇게 하면 HMR 안 될 수 있음
```

**해결:** Default export만 사용하거나, Named export만 사용

**원인 3: 컴포넌트 외부에 상태 정의**
```javascript
// 안 좋음
let count = 0

export default function Counter() {
  return <div>{count}</div>
}

// 좋음 (컴포넌트 내부로)
export default function Counter() {
  const [count, setCount] = useState(0)
  return <div>{count}</div>
}
```

### 5.3 성능 최적화

#### 1) 의존성 사전 번들링 최적화

```javascript
// vite.config.js
export default defineConfig({
  optimizeDeps: {
    include: ['large-package'],  // 큰 패키지는 명시적으로 포함
    exclude: ['very-small-esm-package'],  // 작은 ESM 패키지는 제외
  },
})
```

#### 2) 청크 분리 전략

```javascript
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          ui: ['@mui/material', '@emotion/react'],
        },
      },
    },
  },
})
```

#### 3) 개발 서버 최적화

```javascript
export default defineConfig({
  server: {
    warmup: {
      // 자주 사용하는 파일 미리 변환
      clientFiles: ['./src/components/**/*.tsx'],
    },
  },
})
```

---

## 6. 2025년 Vite 생태계

### 6.1 Vite 8 - Rolldown 시대

2025년 12월, Vite 8 베타가 출시되었습니다.

**핵심 변화:**
```
Vite 7 이하:
- 개발: esbuild
- 프로덕션: Rollup
→ 두 가지 번들러, 설정 이원화, 동작 차이

Vite 8:
- 개발 + 프로덕션: Rolldown
→ 하나의 번들러, 일관된 동작, 더 빠른 속도
```

**Rolldown이란?**
- Rust로 작성된 JavaScript 번들러
- Rollup의 플러그인 API와 호환
- esbuild 수준의 속도 (10-30배 빠름)
- Oxc (파서, 변환기, 미니파이어)를 내부적으로 사용

**통합 툴체인:**
```
Vite (빌드 도구)
  ↓
Rolldown (번들러)
  ↓
Oxc (컴파일러/파서/미니파이어)
```

모두 VoidZero 팀이 관리하는 일관된 생태계입니다.

**성능 개선 사례:**
- Linear: 46초 → 6초 (7.6배)
- Framer: 전체 빌드 파이프라인에 도입
- 대부분의 프로젝트: 3-16배 빌드 시간 단축

### 6.2 Vite+ (ViteConf 2025 발표)

Vite를 넘어선 통합 개발 도구입니다.

**제공 기능:**
```bash
vite dev      # 개발 서버
vite build    # 프로덕션 빌드
vite+ test    # Vitest
vite+ lint    # Oxlint
vite+ format  # Oxfmt
vite+ bundle  # tsdown (라이브러리 번들링)
vite+ run     # 태스크 러너
```

**특징:**
- 단일 CLI로 통합된 개발 경험
- 모노레포 퍼스트 지원
- 내장 캐싱
- 모든 도구가 네이티브 속도 (Rust/Go 기반)

### 6.3 주요 도구들

#### Vitest - 테스팅 프레임워크
```javascript
// vitest.config.js
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
  },
})
```

**특징:**
- Vite 설정 그대로 사용
- Jest 호환 API
- 매우 빠른 속도
- Browser Mode (실제 브라우저에서 테스트)
- Visual Regression Testing (2025 추가)

#### Oxlint - 고속 린터
```bash
# ESLint 대비 30-100배 빠름
oxlint src/
```

**특징:**
- Rust 기반
- JavaScript 플러그인 지원 (2025 추가)
- Type-aware linting (2025 추가)
- 점진적으로 ESLint 대체 가능

#### Oxfmt - 고속 포매터
```bash
# Prettier 대비 30배 빠름
oxfmt src/
```

### 6.4 프레임워크 지원

Vite는 다양한 프레임워크의 기본 빌드 도구가 되었습니다:

**공식 지원:**
- React
- Vue
- Preact
- Svelte
- Solid
- Lit

**메타 프레임워크:**
- Next.js (Turbopack, Vite 기반 아님)
- Nuxt.js (Vite 기본)
- SvelteKit (Vite 기본)
- Astro (Vite 기본)
- Remix (Vite로 전환)
- SolidStart (Vite 기본)
- Qwik City (Vite 기본)

**도구 통합:**
- Storybook (Vite 지원)
- Vitest (네이티브 통합)
- Playwright (Vite 지원)

### 6.5 2025년 Vite 사용 통계

**State of JS 2025 기준:**
- 사용률: 2021년 30% → 2025년 70%+
- 만족도: 2021-2025 연속 1위
- Webpack 사용률: 점진적 감소

**npm 다운로드:**
- Vite: 주간 750만+ 다운로드
- Webpack: 주간 3000만+ 다운로드 (레거시 프로젝트 포함)

---

## 7. 결론 - 언제 Vite를, 언제 Webpack을?

### 7.1 Vite를 선택해야 하는 경우

✅ **새 프로젝트 시작**
- 특별한 이유가 없다면 Vite 추천

✅ **개발 경험 개선이 필요한 경우**
- 느린 개발 서버 시작
- 느린 HMR
- 복잡한 설정 유지보수

✅ **현대적인 브라우저만 타겟으로 하는 경우**
- Chrome, Firefox, Safari, Edge 최신 버전

✅ **빠른 프로토타이핑**
- 설정 최소화
- 빠른 피드백 루프

✅ **모던 프레임워크 사용**
- React, Vue, Svelte 등

### 7.2 Webpack을 유지해야 하는 경우

⚠️ **극도로 복잡한 빌드 로직**
- 다단계 커스텀 로더
- 특수한 파일 형식 처리

⚠️ **IE11 필수 지원**
- 금융권, 공공기관 등

⚠️ **Module Federation 핵심 기능**
- 마이크로 프론트엔드 아키텍처

⚠️ **대규모 레거시 프로젝트**
- 마이그레이션 비용 > 개선 효과

### 7.3 점진적 전환 전략

**단계 1: 새 프로젝트부터**
- 신규 프로젝트는 Vite로 시작
- 팀원들이 Vite에 익숙해지도록

**단계 2: 작은 프로젝트 전환**
- 설정이 단순한 프로젝트부터
- 마이그레이션 경험 축적

**단계 3: 대형 프로젝트 평가**
- 전환 비용 vs 개선 효과 분석
- 점진적 모듈 분리 고려

**단계 4: 병행 운영**
- 당장 전환이 어렵다면 병행 운영
- 새 모듈은 Vite로 개발

### 7.4 5년차 개발자의 조언

**Webpack을 5년 쓰고, Vite를 2년 쓴 개발자로서:**

1. **Vite는 "더 나은 Webpack"이 아닙니다**
   - 완전히 다른 접근 방식
   - Native ESM 중심 설계
   - 패러다임 전환이 필요

2. **모든 프로젝트에 맞는 도구는 없습니다**
   - 프로젝트 특성 파악이 중요
   - 팀 역량 고려
   - 비즈니스 요구사항 우선

3. **개발 경험은 생산성입니다**
   - 1초씩 100번 = 100초 절약
   - 빠른 피드백 루프 = 더 나은 코드
   - 행복한 개발자 = 더 나은 제품

4. **생태계가 중요합니다**
   - Vite 생태계는 빠르게 성장 중
   - 2025년 현재, 대부분의 라이브러리가 Vite 지원
   - 커뮤니티 활발함

5. **미래를 준비하세요**
   - Rolldown, Oxc 같은 Rust 기반 도구가 대세
   - Native 속도가 표준이 되고 있음
   - Vite는 이 흐름의 선두주자

---

## 8. 면접 예상 질문 & 답변

### Q1. Vite가 Webpack보다 빠른 이유는 무엇인가요?

**답변:**
> "Vite가 빠른 핵심 이유는 세 가지입니다.
>
> 첫째, 개발 환경에서 Native ESM을 활용합니다. Webpack은 모든 모듈을 사전 번들링하지만, Vite는 브라우저가 요청하는 모듈만 즉시 변환해서 제공합니다. 이로 인해 개발 서버가 1-2초 만에 시작됩니다.
>
> 둘째, Dependencies와 Source Code를 분리해서 처리합니다. node_modules의 의존성 패키지는 esbuild로 사전 번들링하고, 개발자가 작성한 소스 코드는 필요할 때만 변환합니다. esbuild는 Go 언어로 작성되어 JavaScript 기반 번들러보다 10-100배 빠릅니다.
>
> 셋째, HMR이 Native ESM 기반으로 동작합니다. Webpack은 프로젝트가 커질수록 HMR이 느려지지만, Vite는 수정된 모듈과 그 직계 의존성만 무효화하기 때문에 앱 크기와 무관하게 즉각적인 HMR을 제공합니다."

---

### Q2. Vite에서 개발과 프로덕션 환경이 다른데, 문제가 없나요?

**답변:**
> "좋은 질문입니다. Vite 7 이하에서는 개발 환경에서 esbuild, 프로덕션에서 Rollup을 사용했기 때문에 이론적으로 동작 차이가 있을 수 있었습니다. 하지만 실무에서는 거의 문제가 없었습니다.
>
> 이유는 두 가지입니다. 첫째, Vite가 플러그인 레이어에서 차이를 추상화했습니다. 둘째, Rollup과 esbuild 모두 ES Module 표준을 따르기 때문에 대부분의 경우 호환됩니다.
>
> 그리고 2025년 12월에 출시된 Vite 8부터는 Rolldown이라는 단일 번들러를 개발과 프로덕션 모두에서 사용합니다. Rolldown은 Rust로 작성되었고 Rollup 플러그인 API와 호환되며, esbuild 수준의 속도를 제공합니다. 이로써 개발/프로덕션 환경 차이 문제가 완전히 해결되었습니다."

---

### Q3. HMR이 정확히 어떻게 동작하나요?

**답변:**
> "HMR은 Hot Module Replacement의 약자로, 페이지 전체를 새로고침하지 않고 수정된 모듈만 교체하는 기능입니다.
>
> Vite의 HMR 동작 과정은 다음과 같습니다:
>
> 1. 개발자가 파일을 수정하고 저장합니다.
> 2. Vite 개발 서버가 파일 변경을 감지합니다.
> 3. 해당 ES 모듈을 무효화하고, WebSocket을 통해 브라우저에 알립니다.
> 4. 브라우저는 무효화된 모듈을 재요청합니다.
> 5. Vite가 변환된 모듈을 제공하고, 브라우저가 모듈을 교체합니다.
>
> React나 Vue 같은 프레임워크 플러그인은 자동으로 HMR Boundary를 설정해줍니다. 예를 들어 컴포넌트를 수정하면, 해당 컴포넌트만 재렌더링되고 상위 컴포넌트의 상태는 유지됩니다.
>
> Webpack의 HMR과 비교하면, Vite는 Native ESM을 활용하기 때문에 프로젝트 크기와 무관하게 일정한 속도를 유지합니다."

---

### Q4. Vite의 단점은 무엇인가요?

**답변:**
> "Vite도 만능은 아닙니다. 세 가지 단점이 있습니다.
>
> 첫째, IE11 같은 레거시 브라우저 지원이 복잡합니다. @vitejs/plugin-legacy로 가능하긴 하지만, Webpack보다 설정이 까다롭습니다. 금융권이나 공공기관처럼 IE11을 반드시 지원해야 한다면 Webpack이 더 안정적입니다.
>
> 둘째, 극도로 복잡한 커스텀 빌드 로직이 필요한 경우 Webpack이 더 유연합니다. Vite는 간결함을 위해 의도적으로 제약을 두었기 때문입니다.
>
> 셋째, Webpack Module Federation 같은 일부 고급 기능은 Vite에서 아직 실험적입니다. 마이크로 프론트엔드 아키텍처가 핵심이라면 Webpack 5를 고려해야 합니다.
>
> 하지만 대부분의 현대적인 프로젝트에서는 이런 단점이 크게 문제되지 않습니다. 2025년 현재 Vite 생태계가 빠르게 성장하고 있고, Rolldown 같은 차세대 도구들이 계속 개선되고 있습니다."

---

### Q5. esbuild, Rollup, Rolldown의 차이는 무엇인가요?

**답변:**
> "세 가지 번들러의 특징을 정리하면:
>
> **esbuild**는 Go 언어로 작성되어 매우 빠릅니다. Vite 7 이하에서 개발 환경의 의존성 사전 번들링과 TypeScript/JSX 변환에 사용됩니다. 속도는 뛰어나지만 플러그인 생태계가 제한적이고, 일부 고급 최적화 기능이 부족합니다.
>
> **Rollup**은 JavaScript로 작성되었고 ES Module에 최적화되어 있습니다. 우수한 Tree-shaking과 유연한 플러그인 API를 제공합니다. Vite 7 이하에서 프로덕션 빌드에 사용되었습니다. 안정적이고 생태계가 풍부하지만, JavaScript 기반이라 속도가 상대적으로 느립니다.
>
> **Rolldown**은 Rust로 작성된 차세대 번들러입니다. Rollup의 플러그인 API와 호환되면서도 esbuild 수준의 속도를 제공합니다. Oxc(파서, 변환기, 미니파이어)를 내부적으로 사용하며, Vite 8부터 개발과 프로덕션 모두에서 사용됩니다. esbuild의 속도와 Rollup의 유연성을 모두 가진 것이 특징입니다."

---

### Q6. 언제 Webpack을 쓰고 언제 Vite를 써야 하나요?

**답변:**
> "프로젝트 특성에 따라 선택해야 합니다.
>
> **Vite를 선택해야 하는 경우:**
> - 새 프로젝트를 시작할 때
> - 개발 경험 개선이 필요할 때 (느린 개발 서버, HMR)
> - 현대적인 브라우저만 지원하면 될 때
> - React, Vue, Svelte 같은 모던 프레임워크를 사용할 때
>
> **Webpack을 유지해야 하는 경우:**
> - IE11 필수 지원이 필요할 때
> - 극도로 복잡한 커스텀 빌드 로직이 있을 때
> - Module Federation이 핵심 기능일 때
> - 대규모 레거시 프로젝트에서 마이그레이션 비용이 클 때
>
> 실무적으로는, 특별한 이유가 없다면 신규 프로젝트는 Vite로 시작하는 것을 추천합니다. 기존 프로젝트는 개선 효과와 전환 비용을 비교해서 결정하면 됩니다. 저희 팀은 신규 프로젝트는 모두 Vite로 시작하고, 레거시 프로젝트는 점진적으로 전환하고 있습니다."

---

## 요약

**핵심 포인트:**

1. **Webpack의 한계**: 느린 개발 서버, 느린 HMR, 복잡한 설정
2. **Vite의 핵심**: Native ESM, esbuild, Dependencies/Source 분리
3. **속도**: 개발 서버 4-30배, HMR 즉각 반응, 프로덕션 빌드 3-7배
4. **2025년**: Vite 8 (Rolldown), Vite+, 통합 툴체인
5. **선택 기준**: 프로젝트 특성, 브라우저 지원, 팀 역량

**개인적 결론:**

5년차 개발자로서, Vite는 제가 경험한 가장 큰 생산성 향상 도구입니다. Webpack의 10초 대기는 하루 수백 번 반복되면 엄청난 시간 낭비입니다. Vite의 즉각적인 피드백은 단순히 빠른 것을 넘어서, 개발 경험 자체를 바꿉니다.

물론 모든 프로젝트에 Vite가 정답은 아닙니다. 하지만 2025년 현재, 특별한 이유가 없다면 Vite를 선택하는 것이 합리적입니다. 생태계는 성숙했고, 성능은 검증되었으며, 미래는 더 밝습니다.

---

**작성일**: 2026-01-22  
**작성자**: 5년차 프론트엔드 개발자  
**키워드**: #Vite #Webpack #빌드도구 #번들러 #HMR #esbuild #Rollup #Rolldown #프론트엔드 #개발경험